#+TITLE: orangesoda.net

* Emacs Lisp
** SRFI-2 =and-let*=
   <<SRFI-2.el>> by [[Lang]]. <2009-07-17 Fri>

   =and-let*= is a combination of =and= and =let=, which binds the
   result of each form and tests it for truth. The SRFIs (Scheme
   Request For Implementation) are a collection of well-conceived
   libraries. [[http://srfi.schemers.org/srfi-2/][SRFI-2]] is published at http://srfi.schemers.org/.

#+BEGIN_SRC emacs-lisp
(and-let* ((val (member 'foo '(a b c foo d e)))
           (val (car val)))
  val)
#+END_SRC

   If =foo= was not found in member, the form would return false
   rather than raising an error.

* Javascript
** Fluid Variables (aka Dynamic Scoping, aka Parameters)
   <<fluid.js>> by [[Lang]]. <2009-07-17 Fri>

   Fluid bindings are dynamically scoped; they follow the flow of
   control through the program. See wikipedia on [[http://en.wikipedia.org/wiki/Scope_%28programming%29#Dynamic_scoping][Scoping]]. In standard
   javascript, fluid binding is easy to implement; javascript's model
   of control is very simple. Without threads or continuations,
   exception handling is the only concern.

   The code: [[./javascript/fluid.js][fluid.js]].

** Classic ASP
   by [[Lang]]. <2009-07-17 Fri>

   I'm currently working in classic ASP, which supports javascript as
   server-side language. I'd like to get John Resig's [[http://ejohn.org/blog/bringing-the-browser-to-the-server/][env.js]] working
   in ASP if we continue to use this platform.

*** Order of script evalution
    Classic ASP supports a few different language platforms, although
    it seems rare to see anything other than VBScript and JScript. The
    order of evaluation is:

    0. The language tag.
    1. =<script>= tags in the non-default language.
    2. =<script>= tags in the default language.
    3. Static HTML and =<% %>= blocks in order.

    I've had good success programming in JScript by leaving the
    default language alone and preparing thunks that produce output. I
    can call those thunks in the page as =<% foo_thunk %>=.

    It is wise to avoid this whole mess, of course, and to structure
    projects around a model that supports templates.

** jquery.dataset: HTML5 Dataset jQuery Plugin
   Posted by [[Ben]] on <2009-09-08 Tue>.

   The HTML5 specification allows [[http://dev.w3.org/html5/spec/Overview.html#attr-data][custom data attributes]] to be added
   to any DOM element.  This jQuery plugin provides methods to
   retrieve and manipulate custom attributes.

   Read More: [[./jquery.dataset.org][The jquery.dataset Plugin]]
   
   Download: [[./javascript/jquery.dataset.js][jquery.dataset.js]]

* =ht= templates for HTML
  <<ht>> by [[Lang]]. <2009-07-02 Thu>
  for Javascript, Emacs Lisp, and Scheme (Python coming soon)

** Motivation

- Templates are safe.
- CSS selectors are compact and standard (see HAML).
- printf-style replacements help control types.
- Native lists facilitate writing code to produce =ht= arguments.

** Examples
#+BEGIN_SRC js2
ht(["html",
    ["head",
     ["title", "template test"]],
    ["body",
     ["div#container",
      ["h1#head", "a title"],
      ["p#text", "%s"]]]]);
#+END_SRC

** Sources
   :PROPERTIES:
   :ORDERED:  1
   :END:

*** DONE Javascript (also ASP Jscript): [[./ht/ht.js]]

    The javascript is the proof of concept, and it works. A larger
    part than I anticipated consists of utilities that are in the
    style of jQuery. Using ht server-side, I wanted jQuery
    manipulations pretty frequently, so perhaps the ht format works
    best as jQuery extension.

    The jury is out.

*** TODO Emacs Lisp: [[ht/ht.el]]
    So far, the emacs lisp implementation of ht has yeilded some small
    utilities of convenience. See [[SRFI-2.el]].

* Scheme
** A =REQUIRE= special form for Gambit-C
Posted by [[Ben]] on <2009-07-22 Wed>.

The =REQUIRE= special form includes libraries only once.  It is
implemented using [[http://www.iro.umontreal.ca/~gambit/][Gambit-C]]'s =INCLUDE= and =LOAD= forms with
=COND-EXPAND= to prevent a library from being loaded again (which is
an error) or re-evaluated.

=REQUIRE= accepts a sequence of requirement specifications that
identify libraries.  The specifications are mapped onto the filesystem
to find the corresponding source files or compiled modules.  For
example:

#+BEGIN_SRC scheme
(require (srfi 1)
         (lib util))

;; Library code here...
#+END_SRC

See [[http://github.com/weaver/gambit-prelude/blob/master/require%23.scm][require#.scm]] for additional documentation.  An easy way to
integrate =REQUIRE= into a project is to include [[http://github.com/weaver/gambit-prelude/blob/master/require%23.scm][require#.scm]] from
`.gambcini' or `~/.gambcini'.  For more details, see [[http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html#Customization-1][Customization]] in
the Gambit-C documentation.

Source: [[http://github.com/weaver/gambit-prelude/blob/master/require%23.scm][require#.scm]] [[http://github.com/weaver/gambit-prelude/blob/master/_require.scm][_require.scm]]

* Contributers
** <<Ben>> Weaver

   [[http://benweaver.com/][Ben]] lives in Chattanooga TN and works at [[http://thisismedium.com/][Medium]].  You can follow
   him on [[http://twitter.com/bwvr][Twitter]], see code on [[http://github.com/weaver][github]], or send an email to
   [his-first-name] at orangesoda.net.

** <<Lang>> Martin
* Wibler.com
  Wibler email & apps are hosted by Google:
  - [[http://mail.google.com/a/wibler.com/][email]]
  - [[http://www.google.com/calendar/a/wibler.com/][calendar]]
