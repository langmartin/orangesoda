* Emacs Lisp
** SRFI-2 =and-let*=
   <<SRFI-2.el>>

   =and-let*= is a combination of =and= and =let=, which binds the
   result of each form while also testing it for truth.

#+BEGIN_SRC emacs-lisp
(and-let* ((val (member 'foo '(a b c foo d e)))
           (val (cdr val)))
  val)
#+END_SRC

   If ='foo= was not found in member, the form would return false
   rather than raising an error.

   The SRFIs (Scheme Request For Implementation) are a collection of
   well-conceived libraries, so I like to imitate them in other
   contexts.

* Javascript
** Fluid Variables (aka Dynamic Scoping, aka Parameters)
   Fluid bindings are dynamically scoped; they follow the flow of
   control through the program. See wikipedia on [[http://en.wikipedia.org/wiki/Scope_%28programming%29#Dynamic_scoping][Scoping]]. In standard
   javascript, fluid binding is easy to implement; javascript's model
   of control is very simple. Without threads or continuations,
   exception handling is the only concern.

   The code: [[./javascript/fluid.js][fluid.js]].

** Classic ASP
   I'm currently working in classic ASP, which supports javascript as
   server-side language. I'd like to get John Resig's [[http://ejohn.org/blog/bringing-the-browser-to-the-server/][env.js]] working
   in ASP if we continue to use this platform.

*** Order of script evalution
    Classic ASP supports a few different language platforms, although
    it seems rare to see anything other than VBScript and JScript. The
    order of evaluation is:

    0. The language tag.
    1. =<script>= tags in the non-default language.
    2. =<script>= tags in the default language.
    3. Static HTML and =<% %>= blocks in order.

    I've had good success programming in JScript by leaving the
    default language alone and preparing thunks that produce output. I
    can call those thunks in the page as =<% foo_thunk %>=.

    It is wise to avoid this whole mess, of course, and to structure
    projects around a model that supports templates.

* =ht= templates for HTML
  for Javascript, Emacs Lisp, and Scheme (Python coming soon)

** Motivation
*** Templates are safe.
*** CSS selectors are compact and standard (see HAML).
*** printf-style replacements help control types.
*** Native lists facilitate writing code to produce =ht= arguments.
** Examples
#+BEGIN_SRC js2
ht(["html",
    ["head",
     ["title", "template test"]],
    ["body",
     ["div#container",
      ["h1#head", "a title"],
      ["p#text", "%s"]]]]);
#+END_SRC

** Sources
   :PROPERTIES:
   :ORDERED:  1
   :END:

*** DONE Javascript (also ASP Jscript): [[./ht/ht.js]]
    CLOSED: [2009-07-02 Thu 09:42]

    The javascript is the proof of concept, and it works. A larger
    part than I anticipated consists of utilities that are in the
    style of jQuery. Using ht server-side, I wanted jQuery
    manipulations pretty frequently, so perhaps the ht format works
    best as jQuery extension.

    The jury is out.

*** TODO Emacs Lisp: [[ht/ht.el]]
    So far, the emacs lisp implementation of ht has yeilded some small
    utilities of convenience. See [[SRFI-2.el]].

* Wibler.com
  Wibler is hosted almost entirely at Google:

  - [[http://mail.google.com/a/wibler.com/][email]]
  - [[http://www.google.com/calendar/a/wibler.com/][calendar]]
